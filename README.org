#+TITLE: Dotfiles - passh (Multi-Machine NixOS)
#+AUTHOR: passh
#+DATE: 2026-01-19
#+STARTUP: overview

* TL;DR - Setup Rapido

#+BEGIN_SRC bash
# Clonar dotfiles
git clone <repo> ~/dotfiles
cd ~/dotfiles

# Aplicar NixOS config (FLAKES - metodo actual)
# IMPORTANTE: Ejecutar 'hostname' primero para saber en que maquina estas

# Aurin - necesita --impure (hosts Vocento)
sudo nixos-rebuild switch --flake ~/dotfiles#aurin --impure

# MacBook
sudo nixos-rebuild switch --flake ~/dotfiles#macbook

# Vespino - necesita --impure (hosts Vocento)
sudo nixos-rebuild switch --flake ~/dotfiles#vespino --impure

# Test sin aplicar cambios permanentes
sudo nixos-rebuild test --flake ~/dotfiles#aurin --impure

# Rollback de emergencia
sudo nixos-rebuild switch --rollback
#+END_SRC

* Arquitectura Clone-First (2026-01-19)

** Filosofia

*Todas las maquinas son CLONES IDENTICOS.* Solo se diferencian en hardware.

La configuracion se divide en 3 capas:

#+BEGIN_SRC text
modules/base/       -> Config comun a TODAS las maquinas (desktop, servicios, etc.)
hardware/           -> Config especifica de hardware (nvidia, apple, audio)
hosts/*/            -> Solo servicios y overrides especificos de cada maquina
#+END_SRC

** Estructura del Proyecto

#+BEGIN_SRC text
dotfiles/
|-- flake.nix                    * Entry point (mkSystem para clone-first)
|-- modules/
|   |-- base/                    * BASE UNIFICADA (todas las maquinas)
|   |   |-- default.nix          # Imports: boot, nix-settings, packages, desktop, etc.
|   |   |-- desktop.nix          # LightDM + GNOME + XMonad
|   |   |-- sunshine.nix         # Streaming server (opcional)
|   |   `-- virtualization.nix   # Docker + libvirt
|   |-- common/                  . Modulos legacy (usados por mkNixosConfig)
|   |-- desktop/                 * Wayland: hyprland.nix, niri.nix
|   `-- home-manager/            * Configuracion usuario passh
|-- hardware/                    * MODULOS HARDWARE
|   |-- nvidia/
|   |   |-- rtx5080.nix          # Aurin: RTX 5080 (open drivers)
|   |   `-- rtx2060.nix          # Vespino: RTX 2060
|   |-- apple/
|   |   |-- macbook-pro-13-2.nix # MacBook: keyd, HiDPI, bateria
|   |   `-- snd-hda-macbookpro.nix # MacBook: audio CS8409
|   `-- audio/
|       `-- fiio-k7.nix          # Aurin: DAC/AMP FiiO K7
|-- hosts/                       * HOST-SPECIFIC (solo overrides)
|   |-- aurin/
|   |   |-- hardware-configuration.nix
|   |   `-- default.nix          # VPN bridge, hosts Vocento, etc.
|   |-- macbook/
|   |   |-- hardware-configuration.nix
|   |   `-- default.nix          # Casi vacio (todo viene de base + hardware)
|   `-- vespino/
|       |-- hardware-configuration.nix
|       |-- default.nix          # NFS, Minecraft, VPN VM
|       `-- minecraft.nix        # Servidor Minecraft
|-- xmonad/                      * XMonad config (stow)
|-- nixos-*/                     . Legacy (pre-flakes, backup)
`-- README.org                     Este archivo
#+END_SRC

*Leyenda:* =* Activo= | =. Legacy/migrado=

** Como se construye cada maquina

#+BEGIN_SRC nix
# En flake.nix
aurin = mkSystem {
  hostname = "aurin";
  hardware = [
    ./hardware/nvidia/rtx5080.nix
    ./hardware/audio/fiio-k7.nix
  ];
};

macbook = mkSystem {
  hostname = "macbook";
  hardware = [
    nixos-hardware.nixosModules.apple-macbook-pro
    ./hardware/apple/macbook-pro-13-2.nix
    ./hardware/apple/snd-hda-macbookpro.nix
  ];
};

vespino = mkSystem {
  hostname = "vespino";
  hardware = [
    ./hardware/nvidia/rtx2060.nix
  ];
};
#+END_SRC

** Maquinas

| Maquina | Hardware | Rol | Display Manager |
|---------+----------+-----+-----------------|
| aurin   | Dual Xeon E5-2699v3, RTX 5080, 128GB | Produccion, desarrollo | LightDM |
| macbook | MacBook Pro 2016, Intel, HiDPI | Laptop, movilidad | LightDM |
| vespino | AMD CPU, RTX 2060 | Testing, Minecraft, NFS | LightDM |

* Configuraciones Principales

** Home Manager (~/.config/home-manager/home.nix) *

*Gestiona:* Instalacion de paquetes user-level con Nix

*Caracteristicas:*
- Paquetes desde =stable=, =unstable= y =master=
- Desactiva gestion de configs (usamos stow)
- 200+ paquetes instalados

*Paquetes destacados:*
| Categoria       | Paquetes                                      |
|-----------------+-----------------------------------------------|
| Shells          | fish, zsh, bash                               |
| Editores        | emacs (unstable), neovim, doom-emacs          |
| Development     | php83, nodejs_24, go, python3, rust           |
| Window Manager  | xmonad, xmobar, picom, dmenu                  |
| Tools           | docker, lazydocker, k9s, direnv               |
| Media           | vlc, spotify, obs-studio                      |
| Communication   | telegram-desktop, slack, discord              |
| AI              | ollama, claude-code                           |
| Browsers        | firefox, brave, google-chrome                 |

*Aplicar cambios:*
#+BEGIN_SRC bash
# Con flakes (recomendado) - home-manager integrado en nixos-rebuild
sudo nixos-rebuild switch --flake ~/dotfiles#aurin --impure
#+END_SRC

** NixOS Aurin (/etc/nixos/configuration.nix) *

*Ver documentacion completa:* [[file:nixos-aurin/README.org][nixos-aurin/README.org]]

*Sistema:* Dual Xeon E5-2699v3 + RTX 5080 + FiiO K7 + 128GB RAM

*Caracteristicas principales:*
- NVIDIA RTX 5080 (drivers open-source beta)
- PipeWire optimizado para FiiO K7 DAC/AMP
- Sunshine streaming server (NVENC)
- Virtualizacion KVM/QEMU + Docker
- Ollama + Open WebUI (AI local)
- Dual NIC + bridge para VMs
- NUMA optimizations para dual socket

*Scripts del sistema:*
| Comando          | Descripcion                      |
|------------------+----------------------------------|
| =aurin-info=     | Info completa del sistema        |
| =fiio-k7-test=   | Test DAC/AMP FiiO K7             |
| =sunshine-test=  | Test streaming Sunshine          |
| =xeon-stress=    | Stress test dual Xeon            |
| =numa-info=      | Info NUMA dual socket            |
| =temp-monitor=   | Monitor temperaturas             |

** XMonad (~/.config/xmonad/xmonad.hs) *

*Tiling window manager* escrito en Haskell

*Caracteristicas:*
- Layouts: Tall, ThreeCol, Grid, MultiCol
- Scratchpads: terminal, emacs, jetbrains-toolbox
- Grid selector (M-g)
- Integracion con xmobar
- Keybindings personalizados

*Keybindings importantes:*
| Tecla               | Accion                              |
|---------------------+-------------------------------------|
| =M-p=               | Dmenu (launcher)                    |
| =M-g=               | Grid selector                       |
| =M-S-<Enter>=       | Alacritty                           |
| =M-S-c=             | Cerrar ventana                      |
| =M-<Space>=         | Cambiar layout                      |
| =M-S-f=             | Fullscreen                          |
| =M-[1-9]=           | Cambiar workspace                   |
| =M-S-[1-9]=         | Mover ventana a workspace           |
| =M-j/k=             | Focus siguiente/anterior            |
| =M-h/l=             | Resize master                       |
| =M-S-a=             | Sink all (des-float todas)          |
| =M-S-s=             | Sticky window (all workspaces)      |
| =M-S-k=             | Kill sticky copies                  |
| =M-<F1>=            | Scratchpad terminal                 |
| =M-<F2>=            | Scratchpad Emacs                    |
| =M-<F3>=            | JetBrains Toolbox                   |
| =M-<Print>=         | Flameshot screenshot                |
| =XF86AudioMute=     | Toggle mute                         |
| =XF86AudioRaise=    | Volumen +5%                         |
| =XF86AudioLower=    | Volumen -5%                         |

*Dmenu:* Busca en flatpak apps + nix-profile + $PATH

*Recargar config:*
#+BEGIN_SRC bash
# Recompilar y recargar
M-q

# O manualmente
xmonad --recompile && xmonad --restart
#+END_SRC

** Picom (~/.config/picom/picom.conf) *

*Compositor X11* para transparencias, sombras, animaciones, blur

*Caracteristicas:*
- Backend: GLX (optimizado para RTX 5080)
- VSync: enabled (120Hz)
- Refresh rate: 120
- Transparencias: terminals, rofi, etc.
- Sombras suaves en ventanas
- No borders cuando fullscreen

*Configuracion importante:*
#+BEGIN_SRC conf
backend = "glx";
vsync = true;
refresh-rate = 120;
unredir-if-possible = true;  # Mejor para gaming/video
#+END_SRC

*Recargar:*
#+BEGIN_SRC bash
killall picom
picom &
#+END_SRC

** Fish Shell (~/.config/fish/config.fish) *

*Shell moderno* con autocompletado y syntax highlighting

*Config actual:*
#+BEGIN_SRC fish
# PATH additions
set -x PATH /home/passh/.config/emacs/bin $PATH      # Doom Emacs
set -x PATH /home/passh/node_modules/.bin $PATH      # Node local
set -x PATH /home/passh/.local/bin $PATH             # Local bins
#+END_SRC

*Features:*
- =completions/= - Autocompletados personalizados
- =conf.d/= - Configs adicionales
- =functions/= - Funciones personalizadas

*Uso:*
#+BEGIN_SRC bash
# Cambiar a fish
chsh -s $(which fish)

# O usar temporalmente
fish
#+END_SRC

** Alacritty (~/.config/alacritty/) *

*Terminal emulator* GPU-accelerated

*Configuracion:* Ver =~/.config/alacritty/alacritty.yml=

*Features:*
- Renderizado GPU (OpenGL)
- Scrollback history
- True color support
- Integracion con tmux/byobu

** XMobar (~/.config/xmobar/) *

*Status bar* para XMonad

*Muestra:*
- Workspaces activos
- Layout actual
- Window title
- Posiblemente: CPU, RAM, fecha/hora (ver config)

*Recargar:*
#+BEGIN_SRC bash
killall xmobar
xmobar &
#+END_SRC

** Scripts (~/scripts/) .

*Scripts utiles del sistema*

| Script                            | Descripcion                    |
|-----------------------------------+--------------------------------|
| =ubuntu-vm-ivanti-configurator.sh= | Configurador VM Ubuntu Ivanti  |
| =hdmon.sh=                        | Monitor discos duros?          |
| =vm-backupeitor.sh=               | Backup VMs?                    |

*Nota:* Puede que algunos esten obsoletos o sean especificos de otro setup

** Wallpapers (~/wallpapers/) .

Fondos de pantalla

*Gestion:*
- Nitrogen (GUI)
- O directamente con =feh=

** Shell (bashrc/zshrc) .

*Posiblemente legacy* - Fish es el shell principal

Contiene:
- =.bashrc= - Configuracion Bash
- =.zshrc= - Configuracion Zsh

*Usar?* Probablemente no si usas Fish, pero mantienen compatibilidad

** Composer (~/.config/composer/) .

*PHP Composer* config

Probablemente para desarrollo PHP (tienes php83 en home.nix)

* Guia Stow - Gestion de Dotfiles

** Que es Stow?

GNU Stow crea *enlaces simbolicos* desde tu dotfiles repo a tu $HOME

** Comandos Esenciales

#+BEGIN_SRC bash
cd ~/dotfiles

# Crear enlaces (primera vez)
stow PAQUETE

# Quitar enlaces
stow -D PAQUETE

# Recrear enlaces (cuando cambias cosas)
stow -R PAQUETE

# Ver que va a hacer sin ejecutar
stow -n PAQUETE

# Verbose (siempre recomendado)
stow -v PAQUETE
#+END_SRC

** Workflows Comunes

*** Activar configuracion por primera vez:
#+BEGIN_SRC bash
cd ~/dotfiles
stow -v xmonad
stow -v fish
#+END_SRC

*** Actualizar configuracion existente:
#+BEGIN_SRC bash
# Editar archivo en dotfiles
vim ~/dotfiles/fish/.config/fish/config.fish

# Recrear enlaces (por si acaso)
stow -R fish
#+END_SRC

*** Para NixOS (necesita root y target /):
#+BEGIN_SRC bash
sudo stow -v -R -t / nixos-aurin

# Verificar
ls -la /etc/nixos/

# Aplicar cambios
sudo nixos-rebuild switch
#+END_SRC

** Flags Explicadas

| Flag     | Significado  | Uso                              |
|----------+--------------+----------------------------------|
| =-v=     | Verbose      | Ver que hace stow                |
| =-R=     | Restow       | Quitar y recrear enlaces         |
| =-D=     | Delete       | Solo quitar enlaces              |
| =-t DIR= | Target       | Directorio donde crear enlaces   |
| =-n=     | No execute   | Simular sin ejecutar (dry-run)   |

** Pro Tips

- *Nunca uses =sudo stow=* para archivos de usuario (home)
- *Siempre usa =sudo stow -t /=* para archivos del sistema (/etc)
- *Usa =-R=* cuando dudes, es mas seguro
- *Usa =-v=* siempre para ver que hace
- *Usa =-n=* para testing antes de ejecutar
- *Git tu dotfiles* para backup/sync

** Troubleshooting

*** "Conflicts with existing target"
#+BEGIN_SRC bash
# Ver que conflicta
stow -v -n PAQUETE

# Quitar archivo manual (backup primero)
mv ~/.config/fish/config.fish ~/.config/fish/config.fish.backup

# Volver a stow
stow fish
#+END_SRC

*** "Permission denied"
#+BEGIN_SRC bash
# Para archivos del sistema (/etc)
sudo stow -t / PAQUETE

# Para archivos de usuario (nunca uses sudo)
stow PAQUETE
#+END_SRC

*** Ver enlaces existentes
#+BEGIN_SRC bash
# Ver todos los symlinks en home
find ~ -maxdepth 3 -type l -ls | grep dotfiles

# Ver especifico
ls -la ~/.config/fish/config.fish
#+END_SRC

* Git Workflow

#+BEGIN_SRC bash
cd ~/dotfiles

# Ver cambios
git status
git diff

# Commit cambios
git add .
git commit -m "Update xmonad keybindings"
git push

# En otra maquina
git pull
stow -R xmonad  # Recrear enlaces
#+END_SRC

** Credenciales Git Persistentes

Las credenciales de git se almacenan permanentemente gracias a =credential.helper = store=
configurado en =modules/home-manager/passh.nix=.

*Ubicacion:* =~/.git-credentials=

*Formato del archivo:*
#+BEGIN_SRC text
https://usuario:password@bitbucket.vocento.com
https://usuario:token@github.com
#+END_SRC

*Primera vez:* Git pedira credenciales una vez y las guardara automaticamente.

*Regenerar credenciales:*
#+BEGIN_SRC bash
# Borrar credenciales existentes
rm ~/.git-credentials

# El proximo git push/pull pedira credenciales de nuevo
#+END_SRC

*Seguridad:* El archivo tiene permisos =600= (solo el usuario puede leer/escribir).

* Comandos Mas Usados

#+BEGIN_SRC bash
# Aplicar NixOS config (FLAKES - metodo actual)
sudo nixos-rebuild switch --flake ~/dotfiles#aurin --impure
sudo nixos-rebuild switch --flake ~/dotfiles#macbook
sudo nixos-rebuild switch --flake ~/dotfiles#vespino --impure

# Test sin aplicar permanentemente
sudo nixos-rebuild test --flake ~/dotfiles#aurin --impure

# Rollback
sudo nixos-rebuild switch --rollback

# Activar config stow (solo para xmonad ya)
stow -v -R xmonad
#+END_SRC

* Setup Completo Nueva Maquina

#+BEGIN_SRC bash
# 1. Clonar dotfiles
git clone <repo-url> ~/dotfiles
cd ~/dotfiles

# 2. Aplicar NixOS config (incluye home-manager)
# Cambiar 'aurin' por tu hostname
sudo nixos-rebuild switch --flake ~/dotfiles#aurin --impure

# 3. Aplicar xmonad (unico que aun usa stow)
stow -v xmonad

# 4. Recargar shell
fish

# 5. Reiniciar sesion X (logout/login) o:
xmonad --recompile && xmonad --restart
#+END_SRC

* Notas de Desarrollo

** Home Manager vs NixOS config

- *NixOS config* (=/etc/nixos/configuration.nix=): Sistema base, servicios, hardware
- *Home Manager* (=~/.config/home-manager/home.nix=): Paquetes usuario, configs user-level

** Channels

#+BEGIN_SRC bash
# Ver channels
nix-channel --list

# Deberia mostrar:
# home-manager https://github.com/nix-community/home-manager/archive/release-25.05.tar.gz
#+END_SRC

** Direnv

Tienes =direnv= instalado. Usa =.envrc= en proyectos para cargar variables automaticamente:

#+BEGIN_SRC bash
# En directorio proyecto
echo "use nix" > .envrc
direnv allow
#+END_SRC

* Ejecutar Programas sin Instalar: nix-index, comma y mas

Esta es probablemente la feature mas util de NixOS para el dia a dia.

** El Problema: "command not found"

Imagina este escenario clasico:

#+BEGIN_SRC bash
$ cowsay "hola"
bash: cowsay: command not found
#+END_SRC

En sistemas tradicionales (Ubuntu, Debian), tendrias que:
1. Buscar en Google que paquete contiene =cowsay=
2. Instalar el paquete con =apt install cowsay=
3. Ahora si, ejecutar =cowsay=

Esto es tedioso. Y en NixOS, donde no usamos =apt=, la solucion historica era
aun mas engorrosa. Pero hoy tenemos herramientas *mucho mejores*.

** La Solucion Moderna: comma (,)

#+BEGIN_SRC bash
# En vez de instalar nada, simplemente:
$ , cowsay "hola"
 ______
< hola >
 ------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
#+END_SRC

*Si, es literal una coma seguida del comando.* comma busca automaticamente
que paquete contiene el binario, lo descarga temporalmente, y lo ejecuta.
No queda instalado. Magia.

** Historia: Como Llegamos Aqui

*** Era 1: command-not-found de Ubuntu

Ubuntu popularizo un sistema ingenioso: cuando escribias un comando que no
existia, te sugeria que paquete instalar. NixOS intento copiarlo con
=programs.command-not-found.enable = true=, pero la base de datos estaba
frecuentemente rota o desactualizada.

*** Era 2: nix-index (hazlo tu mismo)

Alguien penso: "Y si generamos nuestra propia base de datos indexando TODO nixpkgs?"

#+BEGIN_SRC bash
$ nix-index  # ADVERTENCIA: tarda 30-60 minutos!
#+END_SRC

Funcionaba, pero nadie quiere esperar una hora cada vez que necesita actualizar.

*** Era 3: nix-index-database (la comunidad al rescate)

La comunidad penso: "Por que cada usuario genera el mismo indice? Hagamoslo
una vez y compartamoslo."

#+BEGIN_SRC text
                  ANTES                         AHORA
                  -----                         -----
Usuario A:  nix-index (60 min)        Descarga DB precompilada (30 seg)
Usuario B:  nix-index (60 min)        Descarga DB precompilada (30 seg)
Usuario C:  nix-index (60 min)        Descarga DB precompilada (30 seg)
#+END_SRC

*** Era 4: comma (el atajo definitivo)

Y finalmente, comma une todo: busca en la DB + descarga + ejecuta, en un comando.

** Las Diferentes Formas de Ejecutar Programas

*** Metodo 1: =, comando= (comma) - USO DIARIO

#+BEGIN_SRC bash
$ , cowsay "el metodo mas facil"
$ , ffmpeg -i video.mp4 -c:v libx264 output.mp4
$ , ncdu /home  # analizar disco sin instalar ncdu
#+END_SRC

Busqueda automatica, cero friccion. *Este es el que usaras el 90% del tiempo.*

*** Metodo 2: =nix shell nixpkgs#= - Shell interactivo

#+BEGIN_SRC bash
$ nix shell nixpkgs#cowsay nixpkgs#lolcat
[shell]$ cowsay "tengo ambos disponibles" | lolcat
[shell]$ exit
#+END_SRC

Util cuando necesitas varios programas juntos en un shell temporal.

*** Metodo 3: =nix run nixpkgs#= - Ejecutar una vez

#+BEGIN_SRC bash
$ nix run nixpkgs#cowsay -- "ejecuto y termino"
$  # Ya volviste a tu shell normal
#+END_SRC

Similar a comma pero especificas el paquete exacto.

*** Metodo 4: =nix-shell -p= - Legacy pero funciona

#+BEGIN_SRC bash
$ nix-shell -p python3 python3Packages.requests
[nix-shell]$ python3 script.py
[nix-shell]$ exit
#+END_SRC

El metodo antiguo (pre-flakes). Todavia util para scripts con shebangs.

** Cuando Usar Cual

#+BEGIN_SRC text
Quiero ejecutar un programa que no tengo instalado
                    |
                    v
        Se que paquete es? ----No----> Usa: , comando
                    |
                   Si
                    |
                    v
        Necesito shell interactivo? --No--> nix run nixpkgs#pkg
                    |
                   Si
                    |
                    v
              nix shell nixpkgs#pkg
#+END_SRC

| Metodo              | Flakes | Interactivo | Busqueda | Caso de Uso        |
|---------------------+--------+-------------+----------+--------------------|
| =, comando=         | Si     | No          | Auto     | *USO DIARIO*       |
| =nix shell nixpkgs#= | Si     | Si          | Manual   | Shell temporal     |
| =nix run nixpkgs#=  | Si     | No          | Manual   | Ejecutar una vez   |
| =nix-shell -p=      | No     | Si          | Manual   | Scripts, legacy    |

** Buscar Paquetes con nix-locate

#+BEGIN_SRC bash
# Que paquete tiene el comando 'rg'?
$ nix-locate bin/rg
ripgrep.out        /nix/store/...-ripgrep-14.1/bin/rg

# Que paquete tiene libcurl?
$ nix-locate 'lib/libcurl.so'
curl.out           /nix/store/...-curl-8.5/lib/libcurl.so
#+END_SRC

** Configuracion en Este Repo

En el =flake.nix=, nix-index-database esta como input:

#+BEGIN_SRC nix
inputs = {
  nix-index-database = {
    url = "github:nix-community/nix-index-database";
    inputs.nixpkgs.follows = "nixpkgs";
  };
};
#+END_SRC

Y se habilita para todas las maquinas:

#+BEGIN_SRC nix
programs.nix-index-database.comma.enable = true;
#+END_SRC

La base de datos se actualiza automaticamente cuando haces =nix flake update=.

** Ejemplos Practicos de Uso Diario

#+BEGIN_SRC bash
# Probar un programa antes de instalarlo
$ , neofetch

# Convertir video (sin tener ffmpeg instalado)
$ , ffmpeg -i input.mp4 -c:v libx265 output.mp4

# Analizar uso de disco
$ , ncdu /home

# Generar QR code
$ , qrencode -o qr.png "https://example.com"

# Ver arbol de procesos
$ , pstree

# Benchmark rapido
$ , hyperfine 'sleep 0.1' 'sleep 0.2'
#+END_SRC

** Scripts Reproducibles con Dependencias

Puedes crear scripts que traen sus propias dependencias:

#+BEGIN_SRC bash
#!/usr/bin/env nix-shell
#!nix-shell -i bash -p cowsay lolcat

# Este script se auto-provee cowsay y lolcat
cowsay "Mis dependencias vienen conmigo" | lolcat
#+END_SRC

O con flakes (mas moderno):

#+BEGIN_SRC bash
#!/usr/bin/env -S nix shell nixpkgs#cowsay nixpkgs#lolcat --command bash

cowsay "Version con flakes" | lolcat
#+END_SRC

** Troubleshooting

*** nix-locate no encuentra nada

#+BEGIN_SRC bash
# Actualizar la base de datos
$ nix flake update nix-index-database ~/dotfiles
$ sudo nixos-rebuild switch --flake ~/dotfiles#aurin
#+END_SRC

*** comma pregunta multiples opciones

#+BEGIN_SRC bash
$ , python
Multiple packages provide 'python':
  1) python2
  2) python3
Select [1-3]:
#+END_SRC

Solucion: especifica el paquete exacto con =, python3 script.py=

* Multiples Versiones de nixpkgs: pkgs vs pkgsMaster

A veces necesitas un paquete mas nuevo de lo que hay en nixpkgs-unstable.
Este repo usa un sistema multi-channel para resolver eso.

** El Problema

#+BEGIN_SRC text
nixpkgs-master  -->  claude-code 2.1.6  (commits de hoy)
     |
     | ~2-7 dias de propagacion
     v
nixpkgs-unstable --> claude-code 2.1.2  (lo que tienes normalmente)
#+END_SRC

Los paquetes fluyen: master -> unstable -> stable. Puede tardar dias o semanas.

** La Solucion: Dos Fuentes de Paquetes

En =flake.nix= tenemos dos inputs de nixpkgs:

#+BEGIN_SRC nix
inputs = {
  nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  nixpkgs-master.url = "github:NixOS/nixpkgs/master";  # Bleeding edge
};
#+END_SRC

Y exponemos ambos a todos los modulos:

#+BEGIN_SRC nix
# En el flake
pkgs = import nixpkgs { ... };          # 99% de paquetes
pkgsMaster = import nixpkgs-master { ... };  # Paquetes nuevos

specialArgs = { inherit pkgsMaster; };  # Disponible en todos los modulos
#+END_SRC

** Uso en Practica

#+BEGIN_SRC nix
# En cualquier modulo (configuration.nix, passh.nix, etc.)
{ pkgs, pkgsMaster, ... }:
{
  home.packages = with pkgs; [
    firefox        # De unstable (estable, testeado)
    git
    python3
  ] ++ [
    pkgsMaster.claude-code    # De master (bleeding edge)
    pkgsMaster.jetbrains-toolbox
  ];
}
#+END_SRC

** Cuando Usar Cada Uno

| Fuente      | Usar para                              | Riesgo      |
|-------------+----------------------------------------+-------------|
| =pkgs=      | 99% de paquetes, uso normal            | Bajo        |
| =pkgsMaster= | Paquetes que necesitas YA (nuevos)     | Medio-alto  |

*Nota:* =pkgsMaster= puede tener paquetes rotos ya que no han pasado todos los tests.
Usalo solo cuando realmente necesites la ultima version.

** Actualizar Independientemente

#+BEGIN_SRC bash
# Actualizar solo master (para paquetes nuevos)
nix flake lock --update-input nixpkgs-master ~/dotfiles

# Actualizar solo unstable (actualizacion normal)
nix flake lock --update-input nixpkgs ~/dotfiles

# Actualizar todo
nix flake update ~/dotfiles
#+END_SRC

* NixOS MacBook Pro 13,2 (2016)

** Hardware Status

| Componente         | Estado | Notas                                          |
|--------------------+--------+------------------------------------------------|
| Audio (CS8409)     | OK     | Driver snd-hda-macbookpro (davidjo)            |
| WiFi (BCM43602)    | NO     | Driver wl abandonado 2019, usar USB dongle     |
| Touch Bar (T1)     | NO     | Chip T1 en recovery mode, workaround con keyd  |
| Webcam FaceTime HD | NO     | Conectada via T1, requiere reset del T1        |
| Teclado/Trackpad   | OK     | Drivers applespi + keyd (fix ISO swap)         |
| Pantalla HiDPI     | OK     | 168 DPI, scaling 2x en GNOME                   |
| Bateria            | OK     | ACPI estandar                                  |
| F-keys (Fn+numero) | OK     | keyd: Fn+1=F1, Fn+=Esc, etc.                   |

** Audio CS8409 - Solucion

El MacBook Pro 2016 usa un chip Cirrus Logic CS8409 como bridge HDA.
El driver del kernel solo soporta Dell (subsystem IDs diferentes).

*Solucion implementada:*
- Modulo custom =snd-hda-macbookpro= compilado desde [[https://github.com/davidjo/snd_hda_macbookpro][davidjo/snd_hda_macbookpro]]
- Parchea el driver del kernel para anadir soporte Apple (GPIO init)
- Config en =nixos-macbook/etc/nixos/modules/snd-hda-macbookpro.nix=

*Verificar funcionamiento:*
#+BEGIN_SRC bash
# Diagnostico completo
audio-diag

# GPIO debe mostrar enable=1 para IO[0-3]
cat /proc/asound/card0/codec#0 | grep -A 10 "^GPIO:"

# Test altavoces
speaker-test -c 2 -t wav
#+END_SRC

** WiFi BCM43602 - Sin solucion

El chip Broadcom BCM43602 interno requiere el driver =wl= (broadcom-sta).

*Estado del driver:*
- El modulo *compila* correctamente (mantenido por RPMFusion/Debian)
- Pero *falla en runtime* con kernel 6.x: =wl driver failed with code 1=
- Error: =NULL ndev->ieee80211ptr, unable to deref wl=
- Causa: APIs internas del kernel incompatibles con el driver propietario

*Conclusion:* El driver esta muerto a nivel funcional, no solo de mantenimiento.
No hay solucion posible sin que Broadcom libere codigo o alguien haga ingenieria inversa.

*Alternativa funcional:* USB WiFi dongle con chip Realtek (RTL8xxxu)
- Ejemplo: TP-Link TL-WN725N o similar
- Funciona out-of-the-box con driver =rtl8xxxu= del kernel

** Touch Bar T1 - Sin solucion

El chip T1 (Touch Bar + Touch ID + *FaceTime HD Camera*) esta en "Recovery Mode" permanente.

*Dispositivos conectados al T1:*
- Touch Bar (OLED strip)
- Touch ID (sensor huella)
- FaceTime HD Camera (720p)
- Ambient Light Sensor

*Problema:*
- El T1 aparece como =05ac:1281= (DFU/Recovery) en lugar de =05ac:8600= (iBridge)
- El firmware esta corrupto o nunca fue inicializado
- Los drivers Linux (apple-ibridge, tiny-dfr, facetimehd) requieren el T1 en modo normal
- Sin T1 funcional, la camara no es visible para el sistema (no hay =/dev/video*=)

*Unica solucion:*
- Conectar a un Mac con macOS
- Usar Apple Configurator 2 para restaurar el firmware del T1
- Sin acceso a macOS = sin Touch Bar

*Workaround con keyd:*
- =Fn + = (tecla junto al 1) = Escape
- =Fn + 1-0= = F1-F10
- =Fn + -= = F11, =Fn + == = F12
- =Fn + Backspace= = Delete
- =Fn + Flechas= = Home/End/PageUp/PageDown

Configurado en =services.keyd= en configuration.nix.

** Teclado Spanish ISO - Fix teclas swapeadas

El teclado Apple SPI tiene las teclas = a= y =< >= intercambiadas respecto al layout fisico.

*Solucion:* keyd remapea las teclas a nivel kernel:
#+BEGIN_SRC nix
"grave" = "102nd";  # Swap tecla junto al 1
"102nd" = "grave";  # Swap tecla entre Shift y Z
#+END_SRC

Esto funciona tanto en X11 (XMonad) como en Wayland (GNOME) porque keyd opera a nivel evdev.

** Solucion: xmobar y fuentes HiDPI

*Estado:* RESUELTO

El problema era usar sintaxis *Xft* (=xft:Font:size=X=) que no escala bien en HiDPI.

*Solucion:* Usar sintaxis *Pango* que SI respeta el DPI del sistema:

#+BEGIN_SRC haskell
-- ANTES (Xft - NO funciona en HiDPI):
font = "xft:Monoid Nerd Font:size=16:bold"

-- DESPUES (Pango - funciona perfectamente):
font = "HeavyData Nerd Font 16"
#+END_SRC

El modulo =modules/home-manager/programs/xmobar.nix= usa Pango y calcula
automaticamente la altura de la barra segun el =fontSize=:

#+BEGIN_SRC nix
# En machines/macbook.nix
dotfiles.xmobar = {
  fontSize = 22;  # Pango escala con DPI automaticamente
};
#+END_SRC

La formula: =TopH = fontSize * 1.8= ajusta la altura de barra proporcionalmente.

** Consola TTY: Temas y Fuentes (2026-01-20)

*Estado:* FUNCIONAL con workaround

*** El problema

El EFI de Apple reporta resolucion incorrecta (3360x2100 en vez de 2560x1600).
Esto causa que el texto en TTY se salga de pantalla.

*Workaround:* =stty cols 160 rows 50= en fish login (automatico).

*** console-theme: Cambio de temas en caliente

Comando para cambiar colores de la consola TTY en caliente:

#+BEGIN_SRC bash
console-theme dark            # Spacemacs Dark (default)
console-theme light           # Spacemacs Light
console-theme commodore       # Fosforo verde CRT retro
console-theme mix             # Synthwave neon
console-theme amber           # CRT ambar retro
console-theme solarized-dark  # Solarized Dark
console-theme solarized-light # Solarized Light
console-theme list            # Ver todos
#+END_SRC

*Nota:* Solo funciona en TTY real (Ctrl+Alt+F1-F6), no en terminales graficos.
Para Alacritty usar =alacritty-theme=.

*** Fuentes de consola disponibles

Fuente actual: *Terminus* (ter-v32n) - LA clasica para programar.

*Terminus* (recomendada):
| Nombre | Tamano | Uso |
|--------+--------+-----|
| ter-v16n | 8x16 | Muchas lineas, puede ser pequena |
| ter-v24n | 12x24 | Balance |
| ter-v32n | 16x32 | HiDPI (actual) |
| ter-v32b | 16x32 | Bold |

*Spleen* (retro):
| Nombre | Tamano | Uso |
|--------+--------+-----|
| spleen-8x16 | 8x16 | Pequena |
| spleen-16x32 | 16x32 | HiDPI |
| spleen-32x64 | 32x64 | ENORME |

Cambiar fuente en =hardware/apple/macbook-pro-13-2.nix=:
#+BEGIN_SRC nix
console.font = lib.mkForce "ter-v32n";
console.packages = lib.mkForce [ pkgs.terminus_font ];
#+END_SRC

** Display Managers: GDM vs LightDM - PARCIAL (2026-01-19)

*Estado:* PARCIAL - XMonad OK, Wayland ROTO

*** El problema

Intentamos usar GDM + GNOME + XMonad como stack unificado en la arquitectura clone-first.
*Ambas maquinas (aurin y macbook) dejaron de arrancar graficamente.*

Sintoma: El sistema arranca, llega a "reached target graphical interface", pero nunca aparece el login.

*** Causa raiz

GDM 49+ tiene problemas con:
1. *NVIDIA*: GDM en modo X11 busca =gnome-session-x11@gnome-login.target= que no existe
2. *XMonad puro*: GDM espera una sesion GNOME completa, no solo un WM

*** Intentos fallidos

1. =services.displayManager.gdm.wayland = false=
   - ERROR: GDM en X11 tiene dependencias rotas con gnome-session
   - Rompio AMBAS maquinas

2. Mover =gdm.wayland = false= solo al modulo NVIDIA
   - Seguia fallando porque el problema es GDM en si

*** Solucion final

Cambiar de GDM a LightDM en =modules/base/desktop.nix=:

#+BEGIN_SRC nix
# ANTES (roto con NVIDIA y XMonad):
services.displayManager.gdm.enable = true;

# DESPUES (funciona perfectamente):
services.xserver.displayManager.lightdm.enable = true;
services.displayManager.defaultSession = "none+xmonad";
#+END_SRC

*** Por que LightDM funciona

- Es simple: solo lanza sesiones, no tiene dependencias complejas
- Funciona con NVIDIA sin configuracion extra
- Puede lanzar cualquier sesion: GNOME, XMonad, Hyprland, etc.
- =display-setup-script= se ejecuta ANTES de crear la sesion X

*** Estado actual de las maquinas

| Maquina | DM | WM/DE | Picom | Estado |
|---------+----+-------+-------+--------|
| aurin | LightDM | XMonad (X11) | home-manager | OK |
| vespino | LightDM | XMonad (X11) | home-manager | OK |
| macbook | LightDM | XMonad (X11) | home-manager | OK |

*** PENDIENTE: Wayland no funciona

*Problema:* LightDM es un display manager X11. Las sesiones Wayland (GNOME, niri, Hyprland) no arrancan correctamente.

*Afectados:*
- GNOME (Wayland) - No arranca
- niri - No arranca
- Hyprland - No arranca

*Posibles soluciones a investigar:*
1. Volver a GDM solo para sesiones Wayland
2. Usar greetd (display manager moderno que soporta Wayland)
3. Usar SDDM con soporte Wayland
4. Login directo desde TTY con =Hyprland= / =niri=

*** Picom: por que no esta en desktop.nix

Picom NO se habilita en =modules/base/desktop.nix= porque conflictua con Mutter (GNOME).

*Solucion implementada:*
1. Picom se configura en home-manager (=modules/home-manager/programs/picom.nix=)
2. =xmonad.hs= lo lanza en =startupHook: spawnOnce "picom"=
3. Cuando usas GNOME, picom NO corre (Mutter hace de compositor)
4. Cuando usas XMonad, picom SI corre

*** Comandos utiles para debugging

#+BEGIN_SRC bash
# Ver que Display Manager esta activo
systemctl status display-manager

# Ver sesiones disponibles
ls /usr/share/xsessions/
ls /usr/share/wayland-sessions/

# Ver variables de sesion
echo $XDG_SESSION_TYPE
echo $XDG_CURRENT_DESKTOP

# Ver si picom esta corriendo
pgrep -a picom

# Ver compositor activo
echo $WAYLAND_DISPLAY  # Si tiene valor, estas en Wayland
#+END_SRC

* CPU Frequency Scaling: Por que tu CPU no siempre va a tope

Imagina que tu coche tuviera solo dos opciones: 0 km/h o 200 km/h. Seria un
desastre: consumiria gasolina como loco y el motor se fundiria. Por eso los
coches tienen marchas. Tu CPU funciona igual.

** El problema: rendimiento vs consumo vs temperatura

Tu procesador puede funcionar a diferentes frecuencias:
- *Frecuencia alta* = mas rendimiento, pero mas calor y consumo
- *Frecuencia baja* = menos rendimiento, pero silencioso y eficiente

La pregunta es: *quien decide cuando subir o bajar?*

En Linux, esto se llama *CPU Frequency Scaling*, y hay dos partes:
1. *Driver*: el que sabe COMO cambiar la frecuencia (habla con el hardware)
2. *Governor*: el que decide CUANDO cambiarla (la politica)

** Los drivers: cada CPU habla su idioma

| Driver        | Para que CPUs                      | Notas                                   |
|---------------+------------------------------------+-----------------------------------------|
| intel_pstate  | Intel modernos (2013+)             | El kernel lo carga solo, muy eficiente  |
| amd-pstate    | AMD Ryzen (Zen 2+)                 | Igual que intel_pstate pero para AMD    |
| acpi-cpufreq  | CPUs antiguos o servidores         | Generico, funciona casi siempre         |

*El problema:* No todos los CPUs cargan su driver automaticamente.

- Los Intel de escritorio/laptop modernos: =intel_pstate= se carga solo
- Los AMD Ryzen modernos: =amd-pstate= se carga solo
- Los Xeon servidor y AMD FX antiguos: necesitan =acpi-cpufreq= manualmente

Por eso en este repo, =modules/common/boot.nix= carga =acpi-cpufreq= para todos.
Si tu CPU ya usa otro driver, simplemente se ignora.

** Los governors: quien manda aqui?

| Governor     | Que hace                                        | Cuando usarlo               |
|--------------+-------------------------------------------------+-----------------------------|
| performance  | Siempre al maximo                               | Compilando, gaming, benchs  |
| powersave    | Siempre al minimo                               | Bateria, silencio total     |
| schedutil    | El kernel decide segun carga (inteligente)      | Uso normal (recomendado)    |
| ondemand     | Sube rapido con carga, baja lento               | Alternativa a schedutil     |
| conservative | Sube/baja gradualmente                          | Servidores, estabilidad     |

*Ojo:* =intel_pstate= solo permite =performance= y =powersave=. El resto de
governors solo funcionan con =acpi-cpufreq=.

** Como esta configurado en cada maquina

*** Aurin - La bestia de 72 hilos

Aurin tiene dos Xeon E5-2699v3, que son CPUs de *servidor*. Curiosidad: aunque
son Intel, el kernel NO carga =intel_pstate= automaticamente para Xeons.
Por que? Porque en servidores se prefiere el control fino de =acpi-cpufreq=.

#+BEGIN_SRC bash
# En aurin veras esto:
$ cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver
acpi-cpufreq

$ cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors
conservative ondemand userspace powersave performance schedutil
#+END_SRC

Con 72 hilos y =schedutil=, el sistema sube/baja la frecuencia de cada core
independientemente. Muy eficiente para workloads variados.

*** Vespino - El veterano AMD FX

Vespino tiene un AMD FX-8350, un procesador de 2012 (arquitectura Bulldozer).
Estos CPUs son anteriores a =amd-pstate=, asi que usan =acpi-cpufreq=.

Antes de anadir el modulo en =boot.nix=, vespino no tenia *ningun* driver de
frecuencia cargado. El resultado? El script de xmobar mostraba "?.?" porque
no encontraba =/sys/devices/system/cpu/cpu0/cpufreq/=.

Ahora con =acpi-cpufreq= cargado, tiene todos los governors disponibles.

*** MacBook - El unico con intel_pstate

El MacBook Pro tiene un Intel Skylake, y este SI carga =intel_pstate= solo.
La diferencia es que solo tiene dos governors: =performance= y =powersave=.

#+BEGIN_SRC bash
# En macbook veras esto:
$ cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver
intel_pstate

$ cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors
performance powersave
# Solo dos! No hay schedutil ni ondemand
#+END_SRC

Por defecto usa =powersave= (es un laptop, prioriza bateria).

** La configuracion en NixOS

Todo esto se configura en dos archivos:

*** 1. Cargar el driver (modules/common/boot.nix)

#+BEGIN_SRC nix
# Una linea que soluciona el problema para CPUs antiguos
boot.kernelModules = [ "acpi-cpufreq" ];
#+END_SRC

Si tu CPU ya usa =intel_pstate= o =amd-pstate=, esta linea no hace nada
(los drivers nativos tienen prioridad). Solo ayuda a los que lo necesitan.

*** 2. GUI para cambiar governor (modules/common/cpupower-gui.nix)

=cpupower-gui= es una app grafica para cambiar el governor sin terminal.
El modulo configura:
- El paquete
- Polkit para no pedir password (si estas en grupo wheel)
- El servicio D-Bus necesario

** Uso diario: el monitor en xmobar

En xmobar veras algo como: =2.3GHz auto=

| Color  | Governor        | Significado                    |
|--------+-----------------+--------------------------------|
| Rojo   | performance     | Al maximo, cuidado con el calor |
| Verde  | powersave       | Ahorrando energia               |
| Cyan   | schedutil/auto  | El kernel decide (normal)       |
| Gris   | none            | Sin cpufreq (fallback a /proc)  |

*Click en el monitor* abre =cpupower-gui= para cambiar el governor.

** Comandos utiles

#+BEGIN_SRC bash
# Ver que tienes
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_driver
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

# Cambiar governor (temporal, hasta reboot)
sudo cpupower frequency-set -g performance   # Al maximo
sudo cpupower frequency-set -g powersave     # Al minimo
sudo cpupower frequency-set -g schedutil     # Automatico

# O simplemente abre la GUI
cpupower-gui
#+END_SRC

** Bonus: ver consumo en watts (RAPL)

Solo CPUs Intel pueden reportar consumo real en watts via RAPL.

#+BEGIN_SRC nix
# En configuration.nix - dar acceso a RAPL sin root
services.udev.extraRules = ''
  SUBSYSTEM=="powercap", ACTION=="add", RUN+="${pkgs.coreutils}/bin/chmod g+r /sys/class/powercap/intel-rapl/intel-rapl:*/energy_uj"
  SUBSYSTEM=="powercap", ACTION=="add", RUN+="${pkgs.coreutils}/bin/chgrp wheel /sys/class/powercap/intel-rapl/intel-rapl:*/energy_uj"
'';
#+END_SRC

Solo disponible en CPUs Intel (Aurin y MacBook). El script =xmobar-cpu.sh= muestra
watts si RAPL esta disponible.

* Doom Emacs: Tree-Sitter y Syntax Highlighting en NixOS

** Que es Tree-Sitter

Tree-sitter es un sistema de parseo incremental que genera arboles de sintaxis abstracta (AST)
para codigo fuente. A diferencia del syntax highlighting tradicional basado en expresiones
regulares, tree-sitter:

- *Parsea el codigo completo* como lo haria un compilador
- *Es incremental*: solo reparsea las partes que cambian
- *Entiende la estructura* del codigo, no solo patrones de texto
- *Es mas rapido* para archivos grandes
- *Proporciona highlighting mas preciso* (distingue variables locales de globales, etc.)

** Tree-sitter en Emacs

Emacs 29+ incluye soporte nativo para tree-sitter (=treesit=), pero necesita *grammars compilados*
para cada lenguaje. Estos grammars son bibliotecas dinamicas (.so en Linux, .dylib en macOS).

*** El Problema en NixOS

Cuando Doom Emacs intenta usar tree-sitter, necesita compilar los grammars si no existen.
Esto falla o se congela en NixOS porque:

1. El compilador de C (gcc/clang) puede no estar en el PATH de Emacs
2. Las rutas de bibliotecas del sistema son diferentes en NixOS
3. El sandbox de Nix complica la compilacion dinamica

** Opciones Disponibles

*** Opcion 1: Deshabilitar Tree-sitter (Recomendado)

Si el syntax highlighting tradicional es suficiente, simplemente quita los flags =+tree-sitter=.

*En =~/.config/doom/init.el=:*

#+BEGIN_SRC emacs-lisp
;; ANTES (con tree-sitter)
:tools
tree-sitter

:lang
(nix +lsp +tree-sitter)
(php +lsp +tree-sitter)

;; DESPUES (sin tree-sitter)
:tools
;;tree-sitter  ; Comentado o eliminado

:lang
(nix +lsp)
(php +lsp)
#+END_SRC

*Aplicar cambios:*
#+BEGIN_SRC bash
~/.config/emacs/bin/doom sync
# Reiniciar Emacs
#+END_SRC

*Pros:* Sin configuracion adicional, funciona inmediatamente, LSP ya proporciona el 90% de los beneficios.

*** Opcion 2: Instalar Grammars via NixOS

NixOS puede preinstalar los grammars compilados. En =modules/home-manager/passh.nix=:

#+BEGIN_SRC nix
home.packages = with pkgs; [
  tree-sitter-grammars.tree-sitter-nix
  tree-sitter-grammars.tree-sitter-javascript
  tree-sitter-grammars.tree-sitter-php
  tree-sitter-grammars.tree-sitter-json
  tree-sitter-grammars.tree-sitter-html
  tree-sitter-grammars.tree-sitter-bash
];
#+END_SRC

Y en =~/.config/doom/config.el=:

#+BEGIN_SRC emacs-lisp
(when (and (fboundp 'treesit-available-p) (treesit-available-p))
  (setq treesit-extra-load-path
        (list (expand-file-name "~/.nix-profile/lib/tree-sitter")
              "/run/current-system/sw/lib/tree-sitter")))
#+END_SRC

** Verificar Estado

#+BEGIN_SRC emacs-lisp
;; M-x eval-expression RET
(treesit-available-p)              ; Deberia retornar t
(treesit-language-available-p 'nix) ; Ver si grammar de nix esta
#+END_SRC

*Modo activo:* Sin tree-sitter usa =nix-mode=, con tree-sitter usa =nix-ts-mode= (sufijo =-ts-=).

** Grammars Disponibles

#+BEGIN_SRC bash
nix search nixpkgs tree-sitter-grammars
#+END_SRC

| Lenguaje   | Paquete Nix                                 |
|------------+---------------------------------------------|
| Nix        | tree-sitter-grammars.tree-sitter-nix        |
| JavaScript | tree-sitter-grammars.tree-sitter-javascript |
| PHP        | tree-sitter-grammars.tree-sitter-php        |
| JSON       | tree-sitter-grammars.tree-sitter-json       |
| HTML       | tree-sitter-grammars.tree-sitter-html       |
| Bash       | tree-sitter-grammars.tree-sitter-bash       |

* Hosts Privados de Trabajo

** El Problema

Para desarrollo necesitamos hosts internos (staging, dev, etc.) que no pueden
estar en un repo publico. El archivo esta en un repo de trabajo externo.

** Por que requiere --impure

En NixOS Flakes, =builtins.pathExists= para paths externos al flake SIEMPRE
devuelve =false= en evaluacion pura. Por eso usamos =--impure=.

** Solucion Actual

#+BEGIN_SRC bash
# Aurin (con hosts de trabajo)
sudo nixos-rebuild switch --flake ~/dotfiles#aurin --impure

# Macbook (requiere clonar repo de trabajo primero)
git clone <work-repo> ~/src/work/work-env
sudo nixos-rebuild switch --flake ~/dotfiles#macbook --impure
#+END_SRC

** Opciones Futuras (cuando haga falta)

| Opcion | Puro? | Complejidad | Notas |
|--------|-------|-------------|-------|
| =--impure= (actual) | No | Baja | Simple, funciona |
| sops-nix | Si | Media | Encripta secretos en repo |
| Repo privado input | Si | Media | Flake input con SSH |

Para implementar sops-nix: [[https://github.com/Mic92/sops-nix][sops-nix GitHub]]

* TODO Tareas Pendientes

- [ ] *WAYLAND ROTO* - LightDM no soporta sesiones Wayland (GNOME, niri, Hyprland)
  - Investigar: greetd, SDDM, o login directo desde TTY
- [ ] *rEFInd* - Bootloader para fix geometria TTY en MacBook
  - =boot.loader.refind.enable = true=
  - Configurar =resolution 2560 1600= en refind.conf
- [ ] Revisar y limpiar configs obsoletas (shell/, composer/)
- [ ] Documentar scripts utiles en scripts/
- [ ] Migrar xmonad a home-manager (si merece la pena)
- [ ] Considerar sops-nix para secretos

* Roadmap: Migracion Stow -> Home Manager

** Contexto

Con la adopcion de NixOS Flakes para multiples maquinas (aurin, macbook), GNU Stow
se vuelve redundante. Home Manager integrado con el flake ofrece:

- *Configs per-machine declarativas* (ej: xmobar con diferentes DPI/fonts)
- *Un solo comando* =nixos-rebuild switch= aplica sistema + usuario
- *Reproducibilidad total* - Todo versionado en el flake
- *Rollback automatico* - Generaciones anteriores disponibles

** Estado Actual (Anti-pattern)

En =modules/home-manager/passh.nix= linea ~253 hay un hack que usa stow dentro de home-manager:

#+BEGIN_SRC nix
activation.linkDotfiles = lib.hm.dag.entryBefore [ "checkLinkTargets" ] ''
  ${pkgs.stow}/bin/stow -v -R -t ${config.home.homeDirectory} \
    alacritty composer fish picom xmobar xmonad claude-code
'';
#+END_SRC

Esto debe eliminarse gradualmente migrando cada config a home-manager nativo.

** Arquitectura Propuesta

#+BEGIN_SRC text
modules/home-manager/
|-- default.nix           # Entry point, recibe hostname
|-- common.nix            # Configs compartidas (paquetes base)
|-- programs/
|   |-- xmobar.nix        # Xmobar con opciones parametrizables
|   |-- xmonad.nix        # XMonad config
|   |-- alacritty.nix     # Terminal
|   `-- fish.nix          # Shell (usa programs.fish nativo)
`-- machines/
    |-- aurin.nix         # fontSize=14, dpi=96, nvidia, interfaces de red
    `-- macbook.nix       # fontSize=22, dpi=168, intel, HiDPI
#+END_SRC

** Pasar hostname al flake

En =flake.nix=, funcion =mkNixosConfig=:

#+BEGIN_SRC nix
home-manager.extraSpecialArgs = {
  inherit inputs;
  hostname = hostname;  # Anadir esto
};
#+END_SRC

** Patron para configs per-machine

#+BEGIN_SRC nix
# modules/home-manager/programs/xmobar.nix
{ config, lib, ... }:

let cfg = config.custom.xmobar;
in {
  options.custom.xmobar = {
    fontSize = lib.mkOption {
      type = lib.types.int;
      default = 14;
    };
    dpi = lib.mkOption {
      type = lib.types.int;
      default = 96;
    };
  };

  config.home.file.".config/xmobar/xmobarrc".text = ''
    Config { font = "xft:Monoid Nerd Font:size=${toString cfg.fontSize}"
           , ...
    }
  '';
}
#+END_SRC

Luego en cada maquina:

#+BEGIN_SRC nix
# machines/macbook.nix
{ ... }: {
  custom.xmobar.fontSize = 22;
  custom.xmobar.dpi = 168;
}

# machines/aurin.nix
{ ... }: {
  custom.xmobar.fontSize = 14;
  # dpi usa default 96
}
#+END_SRC

** Orden de Migracion Recomendado

1. [X] *xmobar* - COMPLETADO (2026-01-04)
   - Modulo parametrizable en =modules/home-manager/programs/xmobar.nix=
   - Configs per-machine en =modules/home-manager/machines/{aurin,macbook}.nix=
   - Opciones: fontSize, gpuType, networkInterface, wifiInterface, showBattery, showTrayer, alsaMixer

2. [X] *alacritty* - COMPLETADO (2026-01-04)
   - Modulo en =modules/home-manager/programs/alacritty.nix=
   - Usa =programs.alacritty= nativo de home-manager
   - Opciones: fontSize (14 aurin, 18 macbook), theme (dark/light)
   - Tema Spacemacs inline

3. [X] *picom* - COMPLETADO (2026-01-04)
   - Modulo en =modules/home-manager/programs/picom.nix=
   - Opcion: backend (egl para NVIDIA, xrender para Intel)
   - Config completa inline (shadows, blur, animations)

4. [X] *fish* - COMPLETADO (2026-01-04)
   - Modulo en =modules/home-manager/programs/fish.nix=
   - Usa =programs.fish= nativo de home-manager
   - Aliases: git shortcuts, eza/ls, nixos helpers
   - Abbreviations: docker, nix

5. [ ] *xmonad* - Pendiente (config Haskell compleja)
   - Actualmente gestionado via stow
   - Requiere analisis de como parametrizar Haskell

6. [ ] *composer* - Pendiente (bajo riesgo, simple)
   - PHP tool, config estatico
   - Baja prioridad

7. [X] Reducir bloque =activation.linkDotfiles= - PARCIALMENTE
   - Solo quedan: xmonad, composer, claude-code
   - Documentado estado en passh.nix lineas 255-276

8. [ ] Eliminar carpetas stow vacias (cuando todo migre)

** Referencias

- [[https://nix-community.github.io/home-manager/][Home Manager Manual]]
- [[https://nixos.wiki/wiki/Flakes][NixOS Flakes Wiki]]

* Estructura Recomendada para Nuevas Configs

Al anadir nueva configuracion:

#+BEGIN_SRC text
dotfiles/
`-- nueva-app/
    `-- .config/
        `-- nueva-app/
            `-- config.conf
#+END_SRC

Luego:
#+BEGIN_SRC bash
stow nueva-app
#+END_SRC

Esto crea: =~/.config/nueva-app/config.conf= -> =~/dotfiles/nueva-app/.config/nueva-app/config.conf=

* Referencias

- [[https://nixos.org/manual/nixos/stable/][NixOS Manual]]
- [[https://nix-community.github.io/home-manager/][Home Manager Manual]]
- [[https://xmonad.org/][XMonad Documentation]]
- [[https://www.gnu.org/software/stow/manual/stow.html][GNU Stow Manual]]
- [[https://github.com/alacritty/alacritty][Alacritty]]
- [[https://wiki.archlinux.org/title/Picom][Picom Wiki]]
- [[file:nixos-aurin/README.org][NixOS Aurin Specific Docs]]

---

*Ultima actualizacion:* 2026-01-19
*Arquitectura:* Clone-First (mkSystem)
*Display Manager:* LightDM (todas las maquinas)
*Sistemas:* Aurin, MacBook, Vespino (NixOS 25.05)
*Shell principal:* Fish
*Window Manager:* XMonad
*Terminal:* Alacritty

*Documentacion adicional:*
- [[file:docs/MACBOOK-INSTALL-GUIDE.org][Guia instalacion MacBook]] - Paso a paso para instalar NixOS en MacBook Pro 2016
- [[file:CLAUDE.md][CLAUDE.md]] - Instrucciones rapidas para Claude AI
